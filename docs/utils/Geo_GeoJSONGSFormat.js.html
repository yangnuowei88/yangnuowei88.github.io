<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: Geo/GeoJSONGSFormat.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="",baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body class="dark" data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">GeoOnline 基础JS工具库</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="FKzVj-bXnPMgYEj6_gg0n"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-Array.html">Array</a></div><div class="sidebar-section-children"><a href="module-Date.html">Date</a></div><div class="sidebar-section-children"><a href="module-Dom.html">Dom</a></div><div class="sidebar-section-children"><a href="module-Easings.html">Easings</a></div><div class="sidebar-section-children"><a href="module-File.html">File</a></div><div class="sidebar-section-children"><a href="module-Geo.html">Geo</a></div><div class="sidebar-section-children"><a href="module-Math.html">Math</a></div><div class="sidebar-section-children"><a href="module-Object.html">Object</a></div><div class="sidebar-section-children"><a href="module-Random.html">Random</a></div><div class="sidebar-section-children"><a href="module-Regular.html">Regular</a></div><div class="sidebar-section-children"><a href="module-Storage.html">Storage</a></div><div class="sidebar-section-children"><a href="module-String.html">String</a></div><div class="sidebar-section-children"><a href="module-Tree.html">Tree</a></div><div class="sidebar-section-children"><a href="module-TypeJudge.html">TypeJudge</a></div><div class="sidebar-section-children"><a href="module-Url.html">Url</a></div><div class="sidebar-section-children"><a href="module-Vue.html">Vue</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="_RIXkGOss6J6hv-Rio_dO"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="EventSystem.html">EventSystem</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="1a4WajAA34VB3hX6jmFPB"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#EventSystemInstance">EventSystemInstance</a></div><div class="sidebar-section-children"><a href="global.html#GeoJSONGSFormat">GeoJSONGSFormat</a></div><div class="sidebar-section-children"><a href="global.html#deepClone">deepClone</a></div><div class="sidebar-section-children"><a href="global.html#throttle">throttle</a></div><div class="sidebar-section-children"><a href="global.html#timeChunk">timeChunk</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"><div class="navbar-item"><a id="" href="http://git.geoonline.geo/geoonline_team1/V10/geoonlineutil_front/-/tree/develop" target="_blank">GitLab 仓库</a></div></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">Geo_GeoJSONGSFormat.js</h1></header><article><pre class="prettyprint source lang-js"><code>/**
 * @classdesc  读写GeoJSON。创建一个新的解析器JSON格式化类。
 *
 */
export const GeoJSONGSFormat = GeoGlobe.Class4OL(GeoGlobe.Format.JSON, {
    /**
     * ignoreExtraDims- 读取几何时忽略高于2的尺寸。
     * @memberof GeoJSONGSFormat.prototype
     * @type {Boolean}
     */

    ignoreExtraDims: true,

    /**
     * 为GeoJSON创建一个新的解析器。
     * @param {Object} options - 一个可选对象，其属性将在此实例上设置。
     */

    /**
     *  反序列化GeoJSON字符串。
     * @memberof GeoJSONGSFormat.prototype
     * @param {String}json -  一个GeoJSON字符串
     * @param {String}type -  用于确定输出结构的可选字符串。 支持的值是“Geometry”，
     * “feature”和“FeatureCollection”。
     * 如果缺失或为空，则假定缺省为“FeatureCollection”。
     * @param {Function} filter - 将在最终结果的每个级别调用每个键和值的函数。
     * 每个值将被过滤器功能的结果替换。
     * 这可用于将通用对象改为类的实例，
     * 或将日期字符串转换为Date对象。
     * @returns {Object} 返回值取决于类型参数的值。
     * 如果type是“FeatureCollection”（默认），则返回将是一个GeoGlobe.Feature数组。
     * 如果type是“Geometry”，则输入json必须表示单个几何体，并且返回将是GeoGlobe.Geometry。
     * 如果type是“Feature”，则输入json必须表示一个特征，返回值将是GeoGlobe.Feature。
     */
    transformRead: function (json, type, filter) {
        type = type ? type : 'FeatureCollection';
        let results = null;
        let obj = null;
        if (typeof json == 'string') {
            obj = GeoGlobe.Format.JSON.prototype.read.apply(this, [
                json,
                filter,
            ]);
        } else {
            obj = json;
        }
        if (!obj) {
            GeoGlobe.Console.error('Bad JSON: ' + json);
        } else if (typeof obj.type != 'string') {
            GeoGlobe.Console.error('Bad GeoJSON - no type: ' + json);
        } else if (this.isValidType(obj, type)) {
            switch (type) {
                case 'Geometry':
                    try {
                        results = this.parseGeometry(obj);
                    } catch (err) {
                        GeoGlobe.Console.error(err);
                    }
                    break;
                case 'Feature':
                    try {
                        results = this.parseFeature(obj);
                        results.type = 'Feature';
                    } catch (err) {
                        GeoGlobe.Console.error(err);
                    }
                    break;
                case 'FeatureCollection':
                    // for type FeatureCollection, we allow input to be any type
                    results = [];
                    switch (obj.type) {
                        case 'Feature':
                            try {
                                results.push(this.parseFeature(obj));
                            } catch (err) {
                                results = null;
                                GeoGlobe.Console.error(err);
                            }
                            break;
                        case 'FeatureCollection':
                            for (
                                let i = 0, len = obj.features.length;
                                i &lt; len;
                                ++i
                            ) {
                                try {
                                    results.push(
                                        this.parseFeature(obj.features[i])
                                    );
                                } catch (err) {
                                    results = null;
                                    GeoGlobe.Console.error(err);
                                }
                            }
                            break;
                        default:
                            try {
                                const geom = this.parseGeometry(obj);
                                results.push(new GeoGlobe.Feature(geom));
                            } catch (err) {
                                results = null;
                                GeoGlobe.Console.error(err);
                            }
                    }
                    break;
            }
        }
        return results;
    },

    /**
     * Check if a GeoJSON object is a valid representative of the given type.
     * @memberof GeoJSONGSFormat.prototype
     * @returns {Boolean} The object is valid GeoJSON object of the given type.
     * @private
     */
    isValidType: function (obj, type) {
        let valid = false;
        switch (type) {
            case 'Geometry':
                if (
                    GeoGlobe.Util.indexOf(
                        [
                            'Point',
                            'MultiPoint',
                            'LineString',
                            'MultiLineString',
                            'Polygon',
                            'MultiPolygon',
                            'Box',
                            'GeometryCollection',
                        ],
                        obj.type
                    ) == -1
                ) {
                    // unsupported geometry type
                    GeoGlobe.Console.error(
                        'Unsupported geometry type: ' + obj.type
                    );
                } else {
                    valid = true;
                }
                break;
            case 'FeatureCollection':
                // allow for any type to be converted to a feature collection
                valid = true;
                break;
            default:
                // for Feature types must match
                if (obj.type == type) {
                    valid = true;
                } else {
                    GeoGlobe.Console.error(
                        'Cannot convert types from ' + obj.type + ' to ' + type
                    );
                }
        }
        return valid;
    },

    /**
     * Convert a feature object from GeoJSON into an
     *     GeoGlobe.Feature.
     * @memberof GeoJSONGSFormat.prototype
     * @param {Object}obj - An object created from a GeoJSON object
     * @returns {GeoGlobe.Feature} A feature.
     * @private
     */
    parseFeature: function (obj) {
        let feature, geometry, attributes, bbox;
        attributes = obj.properties ? obj.properties : {};
        bbox = (obj.geometry &amp;&amp; obj.geometry.bbox) || obj.bbox;
        // eslint-disable-next-line no-useless-catch
        try {
            geometry = this.parseGeometry(obj.geometry);
        } catch (err) {
            // deal with bad geometries
            throw err;
        }
        feature = new GeoGlobe.Feature(geometry, attributes);
        if (bbox) {
            feature.bounds = GeoGlobe.LngLatBounds.fromArray(bbox);
        }
        if (obj.id) {
            feature.fid = obj.id;
        }
        return feature;
    },

    /**
     * Convert a geometry object from GeoJSON into an GeoGlobe.Geometry.
     * @memberof GeoJSONGSFormat.prototype
     * @param {Object}obj - An object created from a GeoJSON object
     * @returns {GeoGlobe.Geometry} A geometry.
     * @private
     */
    parseGeometry: function (obj) {
        if (obj == null) {
            return null;
        }
        let geometry,
            collection = false;
        if (obj.type == 'GeometryCollection') {
            if (!GeoGlobe.Util.isArray(obj.geometries)) {
                throw 'GeometryCollection must have geometries array: ' + obj;
            }
            const numGeom = obj.geometries.length;
            const components = new Array(numGeom);
            for (let i = 0; i &lt; numGeom; ++i) {
                components[i] = this.parseGeometry.apply(this, [
                    obj.geometries[i],
                ]);
            }
            geometry = new GeoGlobe.Geometry.Collection(components);
            collection = true;
        } else {
            if (!GeoGlobe.Util.isArray(obj.coordinates)) {
                throw 'Geometry must have coordinates array: ' + obj;
            }
            if (!this.parseCoords[obj.type.toLowerCase()]) {
                throw 'Unsupported geometry type: ' + obj.type;
            }
            // eslint-disable-next-line no-useless-catch
            try {
                geometry = this.parseCoords[obj.type.toLowerCase()].apply(
                    this,
                    [obj.coordinates]
                );
            } catch (err) {
                // deal with bad coordinates
                throw err;
            }
        }
        // We don't reproject collections because the children are reprojected
        // for us when they are created.
        if (this.internalProjection &amp;&amp; this.externalProjection &amp;&amp; !collection) {
            geometry.transform(
                this.externalProjection,
                this.internalProjection
            );
        }
        return geometry;
    },

    meterToDegree: function (meter) {
        const degree =
            meter /
            ((Cesium.Math.TWO_PI * Cesium.Ellipsoid.WGS84.radii.x) / 360);
        return degree;
    },

    degreeToMeter: function (degrees) {
        return degrees * (Math.PI / 180.0) * Cesium.Ellipsoid.WGS84.radii.x;
    },

    //笛卡尔坐标转换为高斯坐标，仅在平面三维模式下使用。
    getGaussFromCartesianMy: function (cartesian, extent, x) {
        const webMerProj = new Cesium.WebMercatorProjection();
        const lonlat = [30, 0]; //经纬度[30,0]对应的墨卡托坐标[3339584.723798207, 0]
        const mercatorCoord = webMerProj.project(
            Cesium.Cartographic.fromDegrees(lonlat[0], lonlat[1])
        );
        //墨卡托坐标[3339584.723798207, 0]
        const e = [mercatorCoord.x, mercatorCoord.y];

        const radCoord = Cesium.Cartographic.fromCartesian(cartesian);
        //墨卡托坐标 参数cartesian转为墨卡托坐标
        x = webMerProj.project(radCoord, x);
        let i = 0;
        const yy = Cesium['defined'](extent)
            ? ((i = (extent['xmin'] + extent['xmax']) / 2 - e[0]),
              (extent['ymin'] + extent['ymax']) / 2 - e[1])
            : ((i = e[0]), e[1]);
        return (x.x = x.x + i), (x.y = x.y + yy), x;
    },

    //高斯坐标转换为笛卡尔坐标，仅在平面三维模式下使用。
    getCartesianFromGaussMy: function (x, y, height, extent, result) {
        const cartographic = this.getCartographicFromGaussMy(
            x,
            y,
            height,
            extent
        );
        if (!Cesium.defined(result)) {
            result = new Cesium.Cartesian3();
        }
        const ret = Cesium.Cartographic.toCartesian(
            cartographic,
            Cesium.Ellipsoid.WGS84,
            result
        );
        return ret;
    },

    getCartographicFromGaussMy: function (x, y, height, extent) {
        let s = null;
        height = Cesium.defaultValue(height, 0);
        let r = [30, 0];
        const cart3 = new Cesium.WebMercatorProjection().project(
            Cesium.Cartographic.fromDegrees(r[0], r[1])
        );
        //墨卡托坐标[3339584.723798207, 0]
        r = [cart3.x, cart3.y];
        if (Cesium.defined(extent)) {
            s = (extent.xmin + extent.xmax) / 2 - r[0];
            r = (extent.ymin + extent.ymax) / 2 - r[1];
        } else {
            s = r[0];
            r = r[1];
        }
        const webMerProj = new Cesium.WebMercatorProjection();
        const cartographic = webMerProj.unproject(
            new Cesium.Cartesian3(x - s, y - r, height)
        );
        return cartographic;
    },

    getRenderDegreeFromGaussMy: function (x, y, height, extent) {
        const cartographic = this.getCartographicFromGaussMy(
            x,
            y,
            height,
            extent
        );
        const xyRes = {};
        xyRes.x = Cesium.Math.toDegrees(cartographic.longitude);
        xyRes.y = Cesium.Math.toDegrees(cartographic.latitude);
        return xyRes;
    },

    /**
     *Object with properties corresponding to the GeoJSON geometry types.
     *     Property values are functions that do the actual parsing.
     * @memberof GeoJSONGSFormat.prototype
     * @type {null}
     * @private
     */
    parseCoords: {
        /**
         * Convert a coordinate array from GeoJSON into an
         *     GeoGlobe.Geometry.
         * @memberof GeoJSONGSFormat.prototype
         * @param {Object}array -  The coordinates array from the GeoJSON fragment.
         *
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        point: function (array) {
            if (this.ignoreExtraDims == false &amp;&amp; array.length != 2) {
                throw 'Only 2D points are supported: ' + array;
            }
            //var cartesian3 = Cesium.Cartesian3.fromGauss(array[0], array[1], 0, extent);
            const extent = Cesium.viewerObj.localOptions.extent;
            let offsetX = 0;
            let offsetY = 0;
            let x = 0;
            let y = 0;
            if (this.toGauss) {
                offsetX =
                    (extent['xmin'] + extent['xmax']) / 2 -
                    this.degreeToMeter(30);
                offsetY = (extent['ymin'] + extent['ymax']) / 2 - 0;

                x = array[0] + offsetX;
                y = array[1] + offsetY;
            } else {
                // offsetX =
                //     30 -
                //     this.meterToDegree((extent['xmin'] + extent['xmax']) / 2);
                // offsetY =
                //     0 -
                //     this.meterToDegree((extent['ymin'] + extent['ymax']) / 2);
                // x = array[0] + offsetX;
                // y = array[1] + offsetY;

                const webMerProj = new Cesium.WebMercatorProjection();
                //还原为高斯坐标
                const gauss = webMerProj.project(
                    Cesium.Cartographic.fromDegrees(array[0], array[1])
                );
                //得到渲染要素的经纬度坐标
                const xy = this.getRenderDegreeFromGaussMy(
                    gauss.x,
                    gauss.y,
                    0,
                    extent
                );
                x = xy.x;
                y = xy.y;
            }
            return new GeoGlobe.Geometry.Point(x, y);
        },

        /**
         * Convert a coordinate array from GeoJSON into an
         *   GeoGlobe.Geometry.
         * @memberof GeoJSONGSFormat.prototype
         * @param {Object}array -  The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        multipoint: function (array) {
            const points = [];
            let p = null;
            for (let i = 0, len = array.length; i &lt; len; ++i) {
                // eslint-disable-next-line no-useless-catch
                try {
                    p = this.parseCoords['point'].apply(this, [array[i]]);
                } catch (err) {
                    throw err;
                }
                points.push(p);
            }
            return new GeoGlobe.Geometry.MultiPoint(points);
        },

        /**
         *  Convert a coordinate array from GeoJSON into an
            GeoGlobe.Geometry.
         * @memberof GeoJSONGSFormat.prototype
         * @param {Object}array -  The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        linestring: function (array) {
            const points = [];
            let p = null;
            for (let i = 0, len = array.length; i &lt; len; ++i) {
                // eslint-disable-next-line no-useless-catch
                try {
                    p = this.parseCoords['point'].apply(this, [array[i]]);
                } catch (err) {
                    throw err;
                }
                points.push(p);
            }
            return new GeoGlobe.Geometry.LineString(points);
        },

        /**
         * Convert a coordinate array from GeoJSON into an
         *     GeoGlobe.Geometry.
         * @memberof GeoJSONGSFormat.prototype
         * @param {Object}array -  The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        multilinestring: function (array) {
            const lines = [];
            let l = null;
            for (let i = 0, len = array.length; i &lt; len; ++i) {
                // eslint-disable-next-line no-useless-catch
                try {
                    l = this.parseCoords['linestring'].apply(this, [array[i]]);
                } catch (err) {
                    throw err;
                }
                lines.push(l);
            }
            return new GeoGlobe.Geometry.MultiLineString(lines);
        },

        /**
         * Convert a coordinate array from GeoJSON into an
             GeoGlobe.Geometry.
         * @memberof GeoJSONGSFormat.prototype
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        polygon: function (array) {
            const rings = [];
            let r, l;
            for (let i = 0, len = array.length; i &lt; len; ++i) {
                // eslint-disable-next-line no-useless-catch
                try {
                    l = this.parseCoords['linestring'].apply(this, [array[i]]);
                } catch (err) {
                    throw err;
                }
                r = new GeoGlobe.Geometry.LinearRing(l.components);
                rings.push(r);
            }
            return new GeoGlobe.Geometry.Polygon(rings);
        },

        /**
         * Convert a coordinate array from GeoJSON into an
            GeoGlobe.Geometry.
         * @memberof GeoJSONGSFormat.prototype
         * @param {Object} array - The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        multipolygon: function (array) {
            const polys = [];
            let p = null;
            for (let i = 0, len = array.length; i &lt; len; ++i) {
                // eslint-disable-next-line no-useless-catch
                try {
                    p = this.parseCoords['polygon'].apply(this, [array[i]]);
                } catch (err) {
                    throw err;
                }
                polys.push(p);
            }
            return new GeoGlobe.Geometry.MultiPolygon(polys);
        },

        /**
         * Convert a coordinate array from GeoJSON into an
             GeoGlobe.Geometry.
         * @memberof GeoJSONGSFormat.prototype
         * @param {Object} array - The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        box: function (array) {
            if (array.length != 2) {
                throw 'GeoJSON box coordinates must have 2 elements';
            }
            return new GeoGlobe.Geometry.Polygon([
                new GeoGlobe.Geometry.LinearRing([
                    new GeoGlobe.Geometry.Point(array[0][0], array[0][1]),
                    new GeoGlobe.Geometry.Point(array[1][0], array[0][1]),
                    new GeoGlobe.Geometry.Point(array[1][0], array[1][1]),
                    new GeoGlobe.Geometry.Point(array[0][0], array[1][1]),
                    new GeoGlobe.Geometry.Point(array[0][0], array[0][1]),
                ]),
            ]);
        },
    },

    /**
     * 将要素，几何图形和要素数组序列化为GeoJSON字符串。
     * @memberof GeoJSONGSFormat.prototype
     * @param {Object}obj -  GeoGlobe.Feature，GeoGlobe.Geometry，或一系列功能。
     * @param {Boolean}pretty - 用换行符和缩进结构化输出。 默认为false。
     * @returns {String} 输入几何体，要素或要素阵列的GeoJSON字符串表示形式。
     */
    write: function (obj, pretty) {
        let geojson = {
            type: null,
        };
        if (GeoGlobe.Util.isArray(obj)) {
            geojson.type = 'FeatureCollection';
            const numFeatures = obj.length;
            geojson.features = new Array(numFeatures);
            for (let i = 0; i &lt; numFeatures; ++i) {
                const element = obj[i];
                if (!(element instanceof GeoGlobe.Feature)) {
                    const msg =
                        'FeatureCollection only supports collections ' +
                        'of features: ' +
                        element;
                    throw msg;
                }
                geojson.features[i] = this.extract.feature.apply(this, [
                    element,
                ]);
            }
        } else if (obj.CLASS_NAME.indexOf('GeoGlobe.Geometry') == 0) {
            geojson = this.extract.geometry.apply(this, [obj]);
        } else if (obj instanceof GeoGlobe.Feature) {
            geojson = this.extract.feature.apply(this, [obj]);
            if (obj.layer &amp;&amp; obj.layer.projection) {
                geojson.crs = this.createCRSObject(obj);
            }
        }
        return GeoGlobe.Format.JSON.prototype.write.apply(this, [
            geojson,
            pretty,
        ]);
    },

    /**
     *  Create the CRS object for an object.
     * @memberof GeoJSONGSFormat.prototype
     * @param {GeoGlobe.Feature} object -
     * @returns {Object} An object which can be assigned to the crs property
     * @private
     */
    createCRSObject: function (object) {
        const proj = object.layer.projection.toString();
        let crs = {};
        if (proj.match(/epsg:/i)) {
            const code = parseInt(proj.substring(proj.indexOf(':') + 1));
            if (code == 4326) {
                crs = {
                    type: 'name',
                    properties: {
                        name: 'urn:ogc:def:crs:OGC:1.3:CRS84',
                    },
                };
            } else {
                crs = {
                    type: 'name',
                    properties: {
                        name: 'EPSG:' + code,
                    },
                };
            }
        }
        return crs;
    },

    /**
     * extract Object with properties corresponding to the GeoJSON types.
       Property values are functions that do the actual value extraction.
     * @memberof GeoJSONGSFormat.prototype
     * @type {null}
     * @private
     */
    extract: {
        /**
         *  Return a partial GeoJSON object representing a single feature.
         * @memberof GeoJSONGSFormat.prototype
         *@param {GeoGlobe.Feature}feature -
         *
         *@returns {Object} An object representing the point.
         *@private
         */
        feature: function (feature) {
            const geom = this.extract.geometry.apply(this, [feature.geometry]);
            const json = {
                type: 'Feature',
                properties: feature.attributes,
                geometry: geom,
            };
            if (feature.fid != null) {
                json.id = feature.fid;
            }
            return json;
        },

        /**
         * Return a GeoJSON object representing a single geometry.
         * @memberof GeoJSONGSFormat.prototype
         * @param {GeoGlobe.Geometry}geometry
         * @returns {Object} An object representing the geometry.
         * @private
         */
        geometry: function (geometry) {
            if (geometry == null) {
                return null;
            }
            if (this.internalProjection &amp;&amp; this.externalProjection) {
                geometry = geometry.clone();
                geometry.transform(
                    this.internalProjection,
                    this.externalProjection
                );
            }
            const geometryType = geometry.CLASS_NAME.split('.')[2];
            const data = this.extract[geometryType.toLowerCase()].apply(this, [
                geometry,
            ]);
            let json;
            if (geometryType == 'Collection') {
                json = {
                    type: 'GeometryCollection',
                    geometries: data,
                };
            } else {
                json = {
                    type: geometryType,
                    coordinates: data,
                };
            }

            return json;
        },

        /**
         * Return an array of coordinates from a point.
         * @memberof GeoJSONGSFormat.prototype
         * @param {GeoGlobe.Geometry.Point}point -
         * @returns {Array} An array of coordinates representing the point.
         * @private
         */
        point: function (point) {
            return [point.x, point.y];
        },

        /**
         * Return an array of point coordinates from a multipoint.
         * @memberof GeoJSONGSFormat.prototype
         * @param {GeoGlobe.Geometry.MultiPoint}multipoint -
         *
         * @returns {Array} An array of point coordinate arrays representing
         *     the multipoint.
         * @private
         */
        multipoint: function (multipoint) {
            const array = [];
            for (let i = 0, len = multipoint.components.length; i &lt; len; ++i) {
                array.push(
                    this.extract.point.apply(this, [multipoint.components[i]])
                );
            }
            return array;
        },

        /**
         * Return an array of coordinate arrays from a linestring.
         * @memberof GeoJSONGSFormat.prototype
         * @param {GeoGlobe.Geometry.LineString}linestring -
         * @returns {Array} An array of coordinate arrays representing
         *     the linestring.
         * @private
         */
        linestring: function (linestring) {
            const array = [];
            for (let i = 0, len = linestring.components.length; i &lt; len; ++i) {
                array.push(
                    this.extract.point.apply(this, [linestring.components[i]])
                );
            }
            return array;
        },

        /**
         * Return an array of linestring arrays from a linestring.
         * @memberof GeoJSONGSFormat.prototype
         * @param {GeoGlobe.Geometry.MultiLineString}multilinestring -
         * @returns {Array} An array of linestring arrays representing
         *     the multilinestring.
         * @private
         */
        multilinestring: function (multilinestring) {
            const array = [];
            for (
                let i = 0, len = multilinestring.components.length;
                i &lt; len;
                ++i
            ) {
                array.push(
                    this.extract.linestring.apply(this, [
                        multilinestring.components[i],
                    ])
                );
            }
            return array;
        },

        /**
         * Return an array of linear ring arrays from a polygon.
         * @memberof GeoJSONGSFormat.prototype
         * @param {GeoGlobe.Geometry.Polygon}polygon -
         * @returns {Array} An array of linear ring arrays representing the polygon.
         * @private
         */
        polygon: function (polygon) {
            const array = [];
            for (let i = 0, len = polygon.components.length; i &lt; len; ++i) {
                array.push(
                    this.extract.linestring.apply(this, [polygon.components[i]])
                );
            }
            return array;
        },

        /**
         * Return an array of polygon arrays from a multipolygon.
         * @memberof GeoJSONGSFormat.prototype
         * @param {GeoGlobe.Geometry.MultiPolygon}multipolygon -
         * @returns {Array} An array of polygon arrays representing
         *     the multipolygon
         * @private
         */
        multipolygon: function (multipolygon) {
            const array = [];
            for (
                let i = 0, len = multipolygon.components.length;
                i &lt; len;
                ++i
            ) {
                array.push(
                    this.extract.polygon.apply(this, [
                        multipolygon.components[i],
                    ])
                );
            }
            return array;
        },

        /**
         *  Return an array of geometries from a geometry collection.
         * @memberof GeoJSONGSFormat.prototype
         * @param {GeoGlobe.Geometry.Collection}collection -
         * @returns {Array} An array of geometry objects representing the geometry
         *     collection.
         * @private
         */
        collection: function (collection) {
            const len = collection.components.length;
            const array = new Array(len);
            for (let i = 0; i &lt; len; ++i) {
                array[i] = this.extract.geometry.apply(this, [
                    collection.components[i],
                ]);
            }
            return array;
        },
    },

    CLASS_NAME: 'GeoJSONGSFormat',
});
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">GeoOnline 基础JS工具库</a><div class="mobile-nav-links"><div class="navbar-item"><a id="" href="http://git.geoonline.geo/geoonline_team1/V10/geoonlineutil_front/-/tree/develop" target="_blank">GitLab 仓库</a></div></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="FKzVj-bXnPMgYEj6_gg0n"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-Array.html">Array</a></div><div class="sidebar-section-children"><a href="module-Date.html">Date</a></div><div class="sidebar-section-children"><a href="module-Dom.html">Dom</a></div><div class="sidebar-section-children"><a href="module-Easings.html">Easings</a></div><div class="sidebar-section-children"><a href="module-File.html">File</a></div><div class="sidebar-section-children"><a href="module-Geo.html">Geo</a></div><div class="sidebar-section-children"><a href="module-Math.html">Math</a></div><div class="sidebar-section-children"><a href="module-Object.html">Object</a></div><div class="sidebar-section-children"><a href="module-Random.html">Random</a></div><div class="sidebar-section-children"><a href="module-Regular.html">Regular</a></div><div class="sidebar-section-children"><a href="module-Storage.html">Storage</a></div><div class="sidebar-section-children"><a href="module-String.html">String</a></div><div class="sidebar-section-children"><a href="module-Tree.html">Tree</a></div><div class="sidebar-section-children"><a href="module-TypeJudge.html">TypeJudge</a></div><div class="sidebar-section-children"><a href="module-Url.html">Url</a></div><div class="sidebar-section-children"><a href="module-Vue.html">Vue</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="_RIXkGOss6J6hv-Rio_dO"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="EventSystem.html">EventSystem</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="1a4WajAA34VB3hX6jmFPB"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#EventSystemInstance">EventSystemInstance</a></div><div class="sidebar-section-children"><a href="global.html#GeoJSONGSFormat">GeoJSONGSFormat</a></div><div class="sidebar-section-children"><a href="global.html#deepClone">deepClone</a></div><div class="sidebar-section-children"><a href="global.html#throttle">throttle</a></div><div class="sidebar-section-children"><a href="global.html#timeChunk">timeChunk</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>